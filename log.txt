0715
## 계정생성 이후 (Sign up -- create view)
1. 로그인 되어있을 때 조건문을 통해 다른 페이지 요청
!! (if not user.is_authenticated('...:...'))
2. bootstrap4 공식 docs에서 installation, quick start
!! pip install django-bootstrap4
!! settings.py 에 bootstrap4 추가
3. bootstrap 로드 후 html 문서 수정(create, login)
!! css 파일 클래스 추가 후 변경 후 브라우저가 변하지 않는다면 캐쉬 문제
4. 네이버 글꼴 추가
!! static >> fonts 하위 폴더 생성 >> otf파일 추가
!! head에 style 태그 추가
!! body 태그에 font-family 변경 나눔스퀘어
5. 세팅즈에서 랭귀지모드 변경 (한글을 원한다면)
!! setting >> lan-mode : 'ko-kr'

CRUD 에서 Login View 까지 완성
Detail view 제작 (Read View)
>>요청을보내는 유저 , 보려는 유저<<
유저 고유 키값(pk)을 서버에서 확인하고
해당 유저 정보를 HTML 문서상에 출력
!! context_object_name을 통해 html 상에서 정보

6. view >> detailview add >> url에 path 추가 >> html 파일생성
!! view 에서 detailview 클래스 생성
!! path 추가시 클래스 기반 view는 .as_view()필수입력

7. header에서 로그인 했을 때 마이페이지 탭 추가
!! detail.html
-----------------------------------------------------------------

0719
CRUD에서 Update view 제작
1. view.py에서 class 생성 (UpdateView)
!! User 객체 그대로 사용
!! context_object_name은 target_user
2. url에 path 추가
!! url에서 appname : name 에서 name에 들어가는 값이 우리가 지정한 name 값
3. update.html 제작
!! 틀은 create.html과 유사
4. detail.html 수정
!! mypage에 회원정보 수정 버튼 추가

5. Delete 뷰 생성 방법은 동일.

6. user의 pk만 알면 누구나 마이페이지 수정 버튼 접근 가능.
!! 따라서 if user == target_user 구문을 통해
!! 해당 유저만 접근하게끔 설정
-----------------------------------------------------------------

0720
기존 부분에서 엉성한 부분 수정
1. detail.html에서 사용자 아이디 바꾸는 부분 비활성화
!! view.py에서 UserCreationForm이 기존 폼 >> ctrl+B로 확인
!! 상속을 통해 form을 커스터마이징 >>forms.py에서 생성
!! 부모클래스와 동일한 클래스 생성 >> super()이용
!! 항상 서버를 만든다고 생각하고 튼튼한 서버를 구축해야한다.

**
Get : inquiry
Post : create, update
**

header에서 조건문 분기한것 처럼
2. user.is_authenticated를 통해 로그인이 안됐을경우 login 페이지로 이동
!! helloworld def 수정 후 views.py에서 조건문 분기를 추가 후 else 리다이렉트
!! update, Delete 클래스도 마찬가지로 바꿈

3. 하지만 로그인이 되어있는것만 확인했음
!! 즉, 4번유저로 로그인을하면 5번유저 디테일도 들어갈 수 있음
!! 위에 작성한 조건에 self.get_object == request.user를 and로 연결
!! 이번엔 HttpResponseForbidden을 리턴

4. decorator는 함수를 인자로 받음
!! 인자로 받은 함수 앞 뒤를 꾸며줌
-----------------------------------------------------------------

0722
1. view.py 첫번째 user.is)authentic ... 지우고 deco 생성
!! 장고에서 제공해주는 login_required 이용
!! 장고에서 기본적으로 /accounts/login/ 이 default이지만
   경로 변경이 필요할 시(login_url = reverse_lazy('account:login'))사용

2. 메소드에서(클래스의 함수) 데코를 적용할 경우
!! 로그인이 되었는지 확인 하는 데코
!! 데코를 변환을 하거나 애초에 메소드를 위한 데코를 만들어야함
!! 하지만 장고에서 이것도 제공해줌 method_decorator(사용할데코)
!! 로그인이 되었을 때 다른 아이디의 update, delete 페이지를 막는 데코도 따로 작성
!! 추가적으로 데코레이터들을 리스트에 넣어서 간단하게 표현가능함

3. server 에서 admin 계정 생성
!! python manage.py creatsuperuser 터미널에 입력
!! superuser을 DB에서 확인

4. 프로필 생성
!! setting.py 에서 STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
!! Media 역시 동일하게 생성하고 디렉토리 수정

-----------------------------------------------------------------

0726
1. profile app 만들기
!! 이미지, 닉네임, 메시지 기능 만들거임
!! 딜리트, 디테일 뷰는 작성 x
!! 프로필은 따로 form을 만들어야 함
!! 터미널에서 python manage.py startapp profileapp
!! app 생성후 메인앱 세팅에서 installed app 목록 추가
!! 메인 앱 urls에서 path 추가
!! model을 먼저 만들어두고 작업

2. model 만들기
!! profileapp models.py 에서Profile 클래스 생성
!! user 객체의 OneToOneField에서 on_delete 옵션의 cascade(종속) 설정
!! image, nickname, message 객체 생성
!! 다작성했으면 migration 작업 필수 !
!! pip install pillow 해야함 (image를 다루기 때문)
!! ** 모델을 변경할 때 마다 터미널에서
   makemigrations(장고가 모델변경을 감지하고 DB 스키마에 변화를 적용하는 방법), migrate
!! 완료 후 DB에 프로필 db 확인

3. form 만들기
!! Meta 정보 >> form이 어떻게 작성되는 지 외부적인 정보를 담음
!! forms.py 생성 후 field에 image, nickname, message 입력
!! user의 경우는 서버에서 직접 관리(요청을 보낸 유저 확인)